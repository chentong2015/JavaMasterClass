性能调优需要分析的方面
1. 基础性能: 硬件层级或者操作系统层级的升级优化
2. 数据库性能: 事务拆分，索引调优，SQL优化，NoSQL引入
3. 应用架构: 引入分布式策略，计算和存储进行水平化，包括提前计算预处理
4. 业务层面: 业务上进行规避或者调整

常见问题
1. 开启指针压缩的情况下，一个oop能表示的最大堆空间的大小? (使用指针来引用堆空间的大小)
   32bits(4个字节) + 3bits(使用的时候补齐000) = 2^35 = 32G => 堆空间有可能不够
2. 任何扩容，使得oop表示更大堆空间?
   增大对齐字节数，使用的时候增加补齐的bit位数
3. 为什么不是16字节对齐?
   防止padding补太多，造成的内存浪费
4. 为什么要保证对象是8个字节的整数倍 ?
   从计算机内部的寻址上考虑，补齐完整的"8个字节整数倍"更有利于寻址的高效，避免过多的计算地址偏移量

TODO. 开启指针压缩
JDK6之后默认开启 -XX:+/-UsrCompressedOops
oop: ordinary object pointer 对象指针
1.1 目的是节省空间，提升jvm运行效率
1.2 开启指针压缩之后，"指针"(包括对象头中的内存指针)的内存地址从8字节压缩成4个字节
1.3 实现原理:
    test1=16Byte  起始存储地址: 0x00000
    test2=32Byte  起始存储地址: 0x01000
    test3=24Byte  起始存储地址: 0x03000
    把"8字节对齐"出来末尾000进行压缩，使用时再补齐0x000

TODO. 如何有效计算对象大小?
空对象: 没有普通属性的类生成的对象
   开启指针压缩: 占16字节=8字节(Mark Word 64位机)+4字节(内存指针)+0+0+4字节(对齐填充)
   未开启指针压缩: 占16字节=8字节(Mark Word 64位机)+8字节(内存指针)+0+0+0字节
非空对象:
   开启指针压缩: 占24字节=8+4+8(2个int类型的属性)+4
   未开启指针压缩: 占24字节=8+8+8(2个int类型的属性+0
数组对象: jol-core
   int[] arr = {1,2,3}
   sout(ClassLayout.parseInstance(arr).toPrintable());