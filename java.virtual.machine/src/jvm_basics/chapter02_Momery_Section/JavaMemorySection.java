package jvm_basics.chapter02_Momery_Section;

public class JavaMemorySection {

    //                      JVM的三大组成部分
    //                        javac Math.java   --->  java Math.class
    //                                                    |
    //         2. 运行时的数据区域(内存模型)                   |
    //   堆      虚拟机栈/线程栈     本地方法栈    <--- 1. 类装载子系统
    //   方法区            程序计数器            <--- 3. 字节码执行引擎(执行代码)

    // OS单个进程内存分配限制 = 最大堆容量 + 最大方法区容量 + 栈(虚拟机栈, 本地方法栈)

    // 1. 虚拟机栈/线程栈: FILO
    //    1.1 为每个线程分配独立的线程栈内存空间
    //    1.2 TODO: 栈帧(Stack Frame)：线程运行方法时，在线程栈内存中分配一片内存区域，用来存储方法调用时的局部变量
    //                                方法结束时，所分配的栈帧内存空间会出栈，满足先进后出的原则
    //    1.3 栈帧划分部分: 分析class字节码执行流程(底层细节)
    //          1.3.1 局部变量表：存放编译期可知的java虚拟机基本数据类型，数据类型以局部变量槽(Slot)表示
    //          1.3.2 操作数栈:
    //          1.3.3 动态链接:
    //          1.3.4 方法出口:
    //
    //    1.4 线程请求的栈深度过大，超过虚拟机允许的深度，则出现StackOverflow


    // 2. 方法区:
    //    线程共享的内存区域，存储已被虚拟机加载的类型信息，常量... 包含运行时常量池;
    // 3. 本地方法栈:
    //     使用本地(Native)方法服务
    // 4. Java堆:   内存中最大的一块，所有线程共享的一块区域，在虚拟机启动时创建
    //              几乎所有的对象实例都存储在这个内存中
    //              GC垃圾回收器管理的内存区域
    //              理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用
    // 5. 程序计数器: 线程私有的内存，存储当前线程所执行的字节码的行号指示器，可用于线程切换后恢复

    // TODO: 从一个类型被new创建，到被回收，JVM内存中经历怎样的过程和变化 ????
    // HotSpot虚拟机对象
    // 1. 对象的创建：类加载/为新对象分配内存
    // 2. 对象的内存布局
    //    对象头：对象自身运行时数据 + 类型指针(类型元数据的指针)
    //    实例数据:对象存储的有效信息
    //    对齐填充:确保任何对象的大小都是8字节的整数倍
    // 3. 对象的访问：使用句柄间接访问 + 指针直接访问(reference直接存储对象地址)
}
