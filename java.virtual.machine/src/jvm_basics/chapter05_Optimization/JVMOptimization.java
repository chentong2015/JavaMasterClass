package jvm_basics.chapter05_Optimization;

// 何为性能调优 ?
// 1. 根据项目需求进行JVM规划和预调优
// 2. JVM虚拟机调优是为了减少GC，特别是Full GC造成的程序的卡顿
// 3. 解决JVM运行过程中出现的问题(OOM)等
public class JVMOptimization {

    // 基本实战调优: 合理设置JVM参数的配置，同时进行压力测试，逐步的优化

    // 案例01：                        亿级流量，每天用户点击上亿次的网站
    //                                日活用户500万，平均用户点击20，30次
    //                                日均50万订单，几个高峰期占80%
    //                    每秒订单1000数                              每秒订单几十单
    //         订单系统(4核8G) / 订单系统(4核8G) / 订单系统(4核8G)
    //              每个订单对象假定1KB(算字段的总和)
    //             每秒300KB订单对象的生成，分配到堆中
    //            下单还设计其他的对象，库存，优惠，积分...*20倍
    //                10倍放大的其他操作

    // 调优方案：
    // 1. JVM参数的设置，根据机器的内存空间大小来设置JVM中数据区的大小 ??
    //    设置堆参数-Xmx(堆的最大值) -Xms(堆的最小值)
    //    > java -Xms3G -Xmx3G -Xss1M -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=512M -jar microservice-server.jar
    //                                                       堆(3G)         方法区/元空间(512M)
    //                                                       Eden(800M)
    //              每秒产生60MB的对象，存放到堆空间中   ----->    S0(100M)       线程栈1 -Xss 1M
    //                                                       S1(100M)       线程栈2 -Xss 1M
    //                                                       Old(2G)
    //    大约14秒左右Eden被占满，然后触发Minor GC，60M的对象大约1秒后都变成垃圾对象
    //    在最后两秒的对象由于方法还没有执行结束，则不会被回收，会被移动到Survivor区，"或者直接移动到老年代" !!
    //    老年代Old(2G)大约会在5，6分钟被占满，之后触发Full GC
    //
    // 2. 调优堆空间的内存分布 !!
    //    > java -Xms3G -Xmx3G -Xmn2G -Xss1M -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=512M -jar microservice-server.jar
    //                                                       堆(3G)         方法区/元空间(512M)
    //                                                       Eden(1.6G)
    //              每秒产生60MB的对象，存放到堆空间中   ----->    S0(200M)       线程栈1 -Xss 1M
    //                                                       S1(200M)       线程栈2 -Xss 1M
    //                                                       Old(1G)
    //      增加年轻代的内存空间，减少老年代所占的大小，使得对象在回收前不被送入Old区
    //      通过对业务的预估，直接在"年轻代"就对对象进行垃圾回收 !!

    // 基于JVM参数的调优设置，分析Java应用支持的最大线程数量
    // 1. 总的栈空间是有限的，一般一个线程栈占空间为1M，单个线程栈所占空间越大，则能创建的越少
    // 2. HotSpot虚拟机默认参数，栈深度在大多数情况下可以支撑(1000-2000)范围的数量 !!
}
