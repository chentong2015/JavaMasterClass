package jvm_basics.chapter05_Optimization;

// 单机几十万并发的系统JVM如何优化 ?
// 背景分析：
// Rocket MQ, Kafka 中间件系统, 单机最大可处理几十万的消息
// 1. 一秒钟几百兆的对象被放入Eden，短时间触Minor GC，同时Survivor区可能放不下，来不及GC直接被放到老年代中
//    老年代的空间被迅速的占满，然后触发Full GC，导致卡顿，客户端发送的请求超时，无法处理 !!
// 2. 在这个期间，可能还有对象没来得及放到磁盘，还在内存中 !!
//
// 调优方案：
// 1. 使用大内存(>64G)，但minor gc仍然需要优化: Eden(30G)内存太大，做GC依然需要化时间，同时还会STW
// 2. 选择合适的垃圾收集器，设置合适的参数
//    一次只回收Eden区的一部分(2G-3G)，收回出来然后立即使用(使用和回收交替)，中间停顿时间短
//    单次的Minor GC是减少的，避免客户端的超时重发，但总的回收一遍之后的时间是增加的
public class JVMOptimizationMaster {

    // TODO: 深入理解JVM 调优案列分析和实战
    
    // 基本实战调优: 合理设置JVM参数的配置，同时进行压力测试，逐步的优化
    //
    // 案例01：                        亿级流量，每天用户点击上亿次的网站
    //                                日活用户500万，平均用户点击20，30次
    //                                日均50万订单，几个高峰期占80%
    //                    每秒订单1000数                              每秒订单几十单
    //         订单系统(4核8G) / 订单系统(4核8G) / 订单系统(4核8G)
    //              每个订单对象假定1KB(算字段的总和)
    //             每秒300KB订单对象的生成，分配到堆中
    //            下单还设计其他的对象，库存，优惠，积分...*20倍
    //                10倍放大的其他操作
    //
    // 调优方案：
    // 1. JVM参数的设置，根据机器的内存空间大小来设置JVM中数据区的大小 ??
    //    设置堆参数: -Xms(堆的最小值) -Xmx(堆的最大值)
    //    > java -Xms3G -Xmx3G -Xss1M -XX:MetaspaceSize=512M
    //           -XX:MaxMetaspaceSize=512M -jar microservice-server.jar
    //                                                       堆(3G)         方法区/元空间(512M)
    //                                                       Eden(800M)
    //              每秒产生60MB的对象，存放到堆空间中   ----->    S0(100M)       线程栈1 -Xss 1M
    //                                                       S1(100M)       线程栈2 -Xss 1M
    //                                                       Old(2G)
    //    大约14秒左右Eden被占满，然后触发Minor GC，60M的对象大约1秒后都变成垃圾对象
    //    在最后两秒的对象由于方法还没有执行结束，则不会被回收，会被移动到Survivor区，"或者直接移动到老年代" !!
    //    老年代Old(2G)大约会在5，6分钟被占满，之后触发Full GC
    //
    // 2. 调优堆空间的内存分布 !!
    //    > java -Xms3G -Xmx3G -Xmn2G -Xss1M -XX:MetaspaceSize=512M
    //           -XX:MaxMetaspaceSize=512M -jar microservice-server.jar
    //                                                       堆(3G)         方法区/元空间(512M)
    //                                                       Eden(1.6G)
    //              每秒产生60MB的对象，存放到堆空间中   ----->    S0(200M)       线程栈1 -Xss 1M
    //                                                       S1(200M)       线程栈2 -Xss 1M
    //                                                       Old(1G)
    //      增加年轻代的内存空间，减少老年代所占的大小，使得对象在回收前不被送入Old区
    //      通过对业务的预估，直接在"年轻代"就对对象进行垃圾回收 !!

}
