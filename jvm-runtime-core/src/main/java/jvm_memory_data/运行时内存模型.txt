1. 线程栈/虚拟机栈: 每个线程分配独立的线程栈内存空间
   1.1 栈帧(Stack Frame)：
         线程运行方法时，在线程栈内存中分配一片内存区域，用来存储方法调用时的局部变量
         方法结束时，所分配的栈帧内存空间会出栈，满足先进后出的原则
         栈帧划分部分: 分析class字节码执行流程(底层细节)
         1.2.1 局部变量表：<-- 局部表当前指针
               表中第一个位置_0存储的是this当前方法的对象
               objRef = new MyClass(); objRef存放对象在堆中的内存地址
               istroe_1 一般是编译期可知的JVM基本数据类型
         1.2.2 操作数栈: <-- 操作数栈当前指针
               iconst_1 / bipush 10 把10压入到栈定的位置
               将指定的数据值(操作数)压入到的内存空间位置, 数据运算过程中临时的内存空间
         1.2.3 动态链接 直接地址: 存放这个方法在方法区的内存地址
               Java里将方法名视为符号，对符号进行解析，通过"符号对应的内存地址"在方法区中找到方法的具体代码
               C++底层源码概念，将符号引用转变成直接引用，然后存储
         1.2.4 方法出口 返回地址: 用来恢复现场
               方法执行完要返回的位置，始终位置栈帧的栈底
   1.2 线程请求的栈深度过大，超过虚拟机栈允许的深度，则出现StackOverflow
   1.3 虚拟机栈的大小?
       最小设置成160k，一般大小为1M ==> 使用-Xss参数设置
       栈深度在大多数情况下可以支撑(1000-2000)范围的数量

2. 方法区: 线程共享的内存区域
   2.1 class对象/类的信息(对象内存数据)，方法对象集合(main方法对象，add方法对象...)
   2.2 常量 + 静态变量 + 常量池
       class文件常量池，运行时常量池，全局常量池
       jdk1.8之前字符串放在永久代，jdk1.8之后移动到堆中
   元空间和永久代是不是同时存在的 ? ==> 它们均是方法区的具体实现 !!
     < jdk1.8  方法区的具体实现叫永久代(PermGen Space)，放在堆上触发GC并产生OOM
     >= jdk1.8 方法区的具体实现叫元空间(Metaspace)，放在本地内存(OS内存，直接内存Native Memory)，操作系统回收，减少GC压力
   为什么要用元空间代替永久代 ?
     永久代，放在堆上，容易产生OOM
     永久代，放在堆上，触发GC，垃圾回收算法不好实现
     硬件发展，内存的增加
   元空间(Metaspace)的默认大小 ?
     实际大约采用50M的内存空间
     20.75M < < 256T 无限
   元空间调优实战：
     最大和最小都设置成一样，防止内存抖动，避免动态扩展
     调测，大概设置成物理内存的1/32
     预留20%-30%的空间

3. 本地方法栈: 为底层使用C或者C++语言实现的方法分配内存空间
   private native void start0(); 带数字的方法的实现一般在OpenJDK中实现

4. 程序计数器: 线程分配的专有内存空间
   2.1 存储当前线程所执行的字节码行号指示器(code index位置)，用于线程切换后恢复
   2.2 由字节码执行引擎来控制值的动态变化

5. 堆: 所有线程共享的一块区域
   5.1 几乎所有的对象实例都存储在这个内存中，受到GC垃圾回收器的管理
   5.2 一般新创建的对象都是存放在Eden区的，当对象撑满Eden内存区的时候触发GC, Minor GC用于回收年轻代
                  |<- Survivor区 ->|
       Eden  -->     S0   -->  S1   -->  老年代
       8/10         1/10     1/10        2/3
       |<--------- 年轻代 -------->|
   5.3 堆的默认大小 ?
       物理内存1/64 ~ 1/4, Java应用最大堆空间默认为系统内存的1/4
   5.4 堆 -> 方法区
       klass pointer: 对象指向所属类的class对象的内存地址

------------------------------------------------------------------------------------------------------------------------
1. 方法执行完，JVM需要做的事情?
   - 恢复局部表指针(根据调用的方法来切换)
   - 恢复操作数栈指针(根据调用的方法来切换)
   - 恢复程序计数器
   - 如果方法有返回地址，需要返回
   - 清理栈帧(程序计数器调用的方法)

2. this指针何时被赋值? ?
   对象创建后，JVM会为其分配一个指向对象本身的this指针，关键字this只能用于方法方法体内
   局部变量表index=0的位置永远存放的是this
   使用aload_0 把this指针压入栈，方便后面使用

3. JVM底层使用C++来实现，C++生成的对象被加载到本地方法栈中
   Java上层通过native method来调用底层的实现
