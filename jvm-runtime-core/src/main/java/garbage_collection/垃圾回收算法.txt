TODO. 引用计数算法：统计一个对象被引用的数目
给对象添加一个引用计数器，任何时候当引用计数器为0的时候表示该对象可以被回收
<该引用计数算法没有办法解决"循环引用"的问题，因此主流的虚拟机并没有使用该算法>

TODO. 可达性分析算法: 在算法分析的过程中会冻结用户线程的运行
一般这个停顿非常短暂且固定，但是时间会随着堆空间的大小而增加
将"GC Roots"作为起点:
  - 线程栈的本地变量/局部变量
    TODO. 当方法执行结束，方法的局部变量所引用的对象将会垃圾回收
  - 本地方法栈的变量
  - 静态变量
从根结点找引用的变量:
  - 如果对象被引用则标记为"非垃圾"，将对象从堆的Eden内存空间转移到Survivor区
  - 反之则为"垃圾"对象

TODO. 并发可达性分析算法: 三色标记算法
过程中由于标记期间应用程序还在继续跑，对象间的引用可能发生变化
三色标记算法会把GC Roots可达性分析遍历过程中遇到的对象，按照"是否访问过"来标记3中颜色
  > 黑色: 对象已经被GC收集器访问过，且这个对象的所有引用也被访问过，黑色标记的对象表示安全存活的，如果有其他对象指向，则无需再遍历
  > 灰色: 对象已经被GC收集器访问过，但这个对象至少有一个引用没被访问过
  > 白色: 对象没有被GC收集器访问过，如果在分析结束阶段仍然是白色的，说明该对象不可达
三色标记算法两大问题
  > 多标: 浮动垃圾
  > 漏标: 读写屏障 -> 增量更新(黑色插入对白色对象的引用，则变成灰色)
        -> 原始快照(灰色要删除对白色对象的引用时，把这个删除记录下来，让其在本轮GC中存活下来)

TODO. 频繁的GC垃圾回收可能会对程序的性能造成影响
1. Mark-Sweep 标记清除算法
   位置不联系，容易在内存空间产生内存碎片 ==> 无需线程同步
   > 黑色：可被回收  ---> 回收后会变成绿色
   > 灰色：存活对象
   > 绿色：未被使用的空间
2. Mark-Copying 标记复制算法 > 分代收集理论(<jdk1.8)
   没有碎片，但是浪费空间(会将内存空间一分为二，用来复制存活的对象)
3. Mark-Compact 标记整理算法
   没有碎片，效率偏低(会将不连续的内存空间进行整理) ==> 这个必须做线程同步
   3.1 标记
   3.2 清理
   3.3 内存整理
   3.4 数据整理
4. G1 基于Region的GC算法，目前普遍使用的算法