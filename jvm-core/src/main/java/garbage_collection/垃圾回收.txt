GC: 字节码执行引擎在后台开启的一个线程，负责回收垃圾对象
垃圾回收器通常是作为一个单独的低优先级的线程运行，清除和回收内存堆中已经死亡或长时间没有使用的对象

TODO: JVM的内存结构是由它支持的GC算法所决定的
堆:                |<- Survivor区 ->|                -> Survivor区S0和S1分别用来做备份，存放"非垃圾"，其余Eden+S0直接清空
         Eden  -->     S0   -->  S1   -->  老年代    -> 一般分代年龄超过15则视为老年代(不同的垃圾收集器数值可能不同)
         8/10         1/10     1/10        2/3
         |<--------- 年轻代 -------->|               -> Minor GC回收的是整个年轻代

GC过程: 当Eden内存区占满之后所触发的垃圾回收机制
0. 为什么年轻代的比例是8:1:1 ?
   对象首先放到Eden区中，大部分对象都是创建都会销毁，真正移动到Survivor区的对象很少，因此比例不高
1. 对象的分代年龄
   一个对象经历过一次GC之后，则分代年龄会加1
   该信息存储在堆存储空间中对象的对象头中的Mark Word中，占4bits(最大值只需要到15)
2. 年轻代的算法：复制算法
3. 老年代GC算法: 大多是标记整理，CGS使用标记清除算法
4. 一般什么样的对象会被放入老年代 ??
   - 大对象直接进入老年代   : 在Survivor区不容易存放
   - 长期存活对象进入老年代 : 单例，静态变量引用的对象，数据连接池，对象缓存池，Spring Bean
   - 对象动态年龄判断      : 如果对象的大小 > Survivor区的50%
   - 老年代空间分配担保机制 : 执行minor gc之前会判断老年代的剩余可用空间，如果可用空间大于所有对象之和...
5. 如果老年代放满了，则会触发"Full GC"回收整个堆的内存空间，
   当"Full GC"回收不了，剩下的都是非垃圾对象，则产出异常: OutOfMemoryError, java heap space
6. 客户端主动调用gc: System.gc()或Runtime.getRuntime().gc(), JVM可以屏蔽掉显式垃圾回收调用

TODO. Java为什么要设计STW机制
在GC的过程中会遍历堆中所有对象，判断是否是"垃圾对象"，这个过程会STW，完了之后立马再恢复线程的执行
如果在这个过程中，允许线程运行，那么这个对象的状态会不停的变化，比如线程结束的时候会从非垃圾变成垃圾
这时不可能再回头循环判断一遍，导致GC垃圾收集失效，甚至无法结束